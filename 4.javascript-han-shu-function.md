# 4.JavaScript函数function

**1. JavaScript函数定义definition**

被设计用来执行特定任务\(specific task\)的代码块\(a block of code\)，只要定义一次代码，可以重复运用，您能够多次向同一函数传递不同的参数，以产生不同的结果，JavaScript 函数会在某代码调用它时被执行。  你要知道想要执行函数\(execute function\)时应该如何去调用和返回\(call and return\)它。 在 JavaScript 函数中声明的变量，会成为函数的局部变量。 局部变量只能在函数内访问。  由于局部变量只能被其函数识别，因此可以在不同函数中使用相同名称的变量。  局部变量在函数开始时创建，在函数完成时被删除。

**2. JavaScript函数语法\(syntax\)**

JavaScript函数是通过关键词\(key word\) function来定义， 然后是函数名和圆括号\(parentheses\) \(\)。  函数名函数名可包含字母、数字、下划线和美元符号，编写规则与\(writing rules\)变量名相同。 圆括号内可以包括由逗号分隔\(separated by comma\)的参数\(parameters\)： （参数\(parameter\)1，参数\(parameter\)2, … ），  函数代码放在花括号里，用return 来返回。 函数参数在英语里是有两个不同的词来对应，一个是function parameters, 另一个是function arguments.   Parameter 是在圆括号中所列的名称，也可以理解为占位符\(placeholder\)，argument是调用\(calling\)函数时有函数接收\(received\)的真实的值\(real value\)。  在函数中，参数\(paratmeters\)是局部变量\(local variable\)。  函数格式如下：

function name\(参数 1, 参数 2, 参数 3\) {

要执行的代码

return

}

**3.** **函数调用\(calling funciton\)**

什么时候会用到函数代码。  在网页事件\(webpage events\)发生时，如用户点击按钮\(use clicks button\)；或者是用JavaScript代码来调用函数代码； 或者是自调用\(self-calling\)（自动\(automatic\)）函数中的代码来调用。 

**4.** **函数返回\(return\)**

当函数被某一条语句调用时，JavaScript将会返回执行代码\(execution codes\)。  当JavaScript到达return语句时， 函数将停止执行\(stop executing\)。  函数通常会计算出返回值\(return value\)， 这个返回值会返回给调用者\(caller\)。

**5.** **为什么使用函数？**

只要定义一次代码\(defined function once\)， 就能够对代码多次重复使用\(reuse many times\)。  可以多次向同一函数输入\(input\)不同的参数\(parameters\)而产生\(produce\)不同的结果。

**6.** **用圆括号（）运算符\(operator\)来调用\(call\)函数**

假设函数名\(function name\)是myFunction，如果不加\(\)来引用函数，它引用的将会是函数对象\(object\)，函数将返回的是函数声明\(function declaration\)，而不是结果\(result\)； 但是如果你加了（）来调用函数，myFunction\(\)将会返回运算的结果\(calculation result\)，而不是所声明的函数。 

**7.** **用作变量值的函数\(functions used as variables value\)**

函数的使用方法和变量是一样的，可以说是在所有类型\(all types of\)的计算\(calculation\)、赋值\(assign value\)与公式中\(formulas\)。  例如，先用变量存储\(store\)函数的值：

var x = myFunction\(5, 6\);

   var answer = “The result is ” + x  + “ .”  ;

然后能够把函数当做变量值直接使用

var answer = “The result is ” + myFunction\(5, 6\) + “ .”  ;

**8. JavaScript局部变量\(local variables\)**

局部变量只能在函数内访问\(accessed\)，在JavaScript函数中声明的变量，会成为函数的局部变量。  由于局部变量只能被其函数识别\(recognized\)， 因此可以在不同函数中使用相同名称\(same name\)的变量。  局部变量是在函数开始的时候创建\(beginning of the functions\)， 在函数完成的时候\(compteted\)被删除\(deleted\)。  在函数执行完后，你再执行函数里面那个变量名， 就会显示\(displayed\) undefined。

**9. JavaScript函数的使用**

**9.1** **函数声明**

语法声明函数：  被声明的函数不会直接执行。它们被“保存供稍后使用”，将在稍后执行，当它们被调用时。  分号用于分隔可执行的 JavaScript 语句。  由于函数声明不是可执行的语句，以分号结尾并不常见。

**9.2** **函数表达式**

JavaScript 函数也可以使用表达式来定义。

**9.3** **函数表达式可以在变量中存储**：

在变量中保存函数表达式之后，此变量可用作函数。  函数实际上是一个匿名函数（没有名称的函数）。  存放在变量中的函数不需要函数名。他们总是使用变量名调用。  函数使用分号结尾，因为它是可执行语句的一部分。

**9.4 Function\(\)** **构造器**

JavaScript 函数是通过 function 关键词定义的。  函数也可以通过名为 Function\(\) 的内建 JavaScript 函数构造器来定义。  无需使用函数构造器。  大多数情况下，您可以避免在 JavaScript 中使用 new 关键词。

**9.5** **函数提升**

Hoisting 是 JavaScript 将声明移动到当前作用域顶端的默认行为。  Hoisting 应用于变量声明和函数声明。  正因如此，JavaScript 函数能够在声明之前被调用：  使用表达式定义的函数不会被提升。

**9.6** **自调用函数**

函数表达式可以作为“自调用”。  自调用表达式是自动被调用（开始）的，在不进行调用的情况下。  函数表达式会自动执行，假如表达式后面跟着 \(\)。  您无法对函数声明进行自调用。

您需要在函数周围添加括号，以指示它是一个函数表达式。

**9.7函数可用作值**

JavaScript 函数可被用作值，  JavaScript 函数可用在表达式中。

**9.8** **函数是对象**

JavaScript 中的 typeof 运算符会为函数返回 "function"。  但是最好是把 JavaScript 函数描述为对象。  JavaScript 函数都有属性和方法。  arguments.length 会返回函数被调用时收到的参数数目。

定义为对象属性的函数，被称为对象的方法。 为创建新对象而设计的函数，被称为对象构造函数（对象构造器）。

**9.9箭头函数**

箭头函数允许使用简短的语法来编写函数表达式。  您不需要 function 关键字、return 关键字和花括号。  箭头函数没有自己的 this。它们不适合定义对象方法。  箭头函数未被提升。它们必须在使用前进行定义。

**10. JavaScript Hoisting**

提升（Hoisting）是 JavaScript 将声明移至顶部的默认行为。

**10.1 JavaScript** **声明会被提升**

在 JavaScript 中，可以在使用变量之后对其进行声明。  Hoisting 是 JavaScript 将所有声明提升到当前作用域顶部的默认行为（提升到当前脚本或当前函数的顶部）。

**10.2 let** **和** **const** **关键字**

用 let 或 const 声明的变量和常量不会被提升！

**10.3 JavaScript** **初始化不会被提升**

JavaScript 只提升声明，而非初始化。

**10.4** **在顶部声明您的变量！**

Hoisting（对很多开发者来说）是 JavaScript 的一种未知的或被忽视的行为。  如果开发者不理解 hoisting，程序也许会包含 bug（错误）。  为了避免 bug，请始终在每个作用域的开头声明所有变量。  由于这就是 JavaScript 解释代码的方式，请保持这个好习惯。  严格模式中的 JavaScript 不允许在未被声明的情况下使用变量。

**11. JavaScript严格模式**

"use strict"; 定义 JavaScript 代码应该以“严格模式”执行。  "use strict" 是 JavaScript 1.8.5 中的新指令（ECMAScript version 5）。  它不算一条语句，而是一段文字表达式，更早版本的 JavaScript 会忽略它。  "use strict"; 的作用是指示 JavaScript 代码应该以“严格模式”执行。  在严格模式中，您无法，例如，使用未声明的变量。

**11.1声明严格模式**

通过在脚本或函数的开头添加 "use strict"; 来声明严格模式。 在脚本开头进行声明，拥有全局作用域（脚本中的所有代码均以严格模式来执行）。  在函数中声明严格模式，拥有局部作用域（只有函数中的代码以严格模式执行）：

**11.2** **为什么使用严格模式？**

严格模式使我们更容易编写“安全的” JavaScript。  严格模式把之前可接受的“坏语法”转变为真实的错误。 举例来说，在普通的 JavaScript 中，错打变量名会创建新的全局变量。在严格模式中，此举将抛出错误，这样就不可能意外创建全局变量。 在普通 JavaScript 中，如果向不可写属性赋值，开发者不会得到任何错误反馈。  在严格模式中，向不可写的、只能读取的、不存在的属性赋值，或者向不存在的变量或对象赋值，将抛出错误。

**11.3** **严格模式中不允许的事项**

在不声明变量的情况下使用变量，是不允许的。  在不声明对象的情况下使用对象也是不允许的。  写入只能获取的属性是不允许的。  删除不可删除的属性是不允许的。  字符串 "eval" 不可用作变量。  with 语句是不允许的。  处于安全考虑，不允许 eval\(\) 在其被调用的作用域中创建变量：

在类似 f\(\) 的函数调用中，this 的值是全局对象。在严格模式中，现在它成为了 undefined。

**11.4** **对未来的保障**

严格模式中不允许使用为未来预留的关键词。  "use strict" 指令只能在脚本或函数的开头被识别。

**12. JavaScript this** **关键词**

this 是什么？

JavaScript this 关键词指的是它所属的对象。 它拥有不同的值，具体取决于它的使用位置。

在方法中，this 指的是所有者对象，在对象方法中，this 指的是此方法的“拥有者”。。  单独的情况下，this 指的是全局对象。  在函数中，this 指的是全局对象。  在函数中，严格模式下，this 是 undefined。  在事件中，this 指的是接收事件的元素。  像 call\(\) 和 apply\(\) 这样的方法可以将 this 引用到任何对象。

**13. JS Let**

ES2015 引入了两个重要的 JavaScript 新关键词：let 和 const。  这两个关键字在 JavaScript 中提供了块作用域（Block Scope）变量（和常量）。 在 ES2015 之前，JavaScript 只有两种类型的作用域：全局作用域和函数作用域。

**13.1** **全局作用域**

全局（在函数之外）声明的变量拥有全局作用域。  全局变量可以在 JavaScript 程序中的任何位置访问。

**13.2** **函数作用域**

局部（函数内）声明的变量拥有函数作用域。  局部变量只能在它们被声明的函数内访问。

**13.3 JavaScript** **块作用域**

通过 var 关键词声明的变量没有块作用域。  在块 {} 内声明的变量可以从块之外进行访问。  在 ES2015 之前，JavaScript 是没有块作用域的。  可以使用 let 关键词声明拥有块作用域的变量。

在块 {} 内声明的变量无法从块外访问。

**13.4重新声明变量**

使用 var 关键字重新声明变量会带来问题。  在块中重新声明变量也将重新声明块外的变量。

使用 let 关键字重新声明变量可以解决这个问题。 在块中重新声明变量不会重新声明块外的变量。

**13.5** **循环作用域**

在循环中使用 var：

**13.6函数作用域**

在函数内声明变量时，使用 var 和 let 很相似。它们都有函数作用域。

**13.7全局作用域**

如果在块外声明声明，那么 var 和 let 也很相似。它们都拥有全局作用域：

**13.8 HTML** **中的全局变量**

使用 JavaScript 的情况下，全局作用域是 JavaScript 环境。  在 HTML 中，全局作用域是 window 对象。  通过 var 关键词定义的全局变量属于 window 对象：  通过 let 关键词定义的全局变量不属于 window 对象：

**13.9** **重新声明**

允许在程序的任何位置使用 var 重新声明 JavaScript 变量：

在相同的作用域，或在相同的块中，通过 let 重新声明一个 var 变量是不允许的：

在相同的作用域，或在相同的块中，通过 let 重新声明一个 let 变量是不允许的：

在相同的作用域，或在相同的块中，通过 var 重新声明一个 let 变量是不允许的：

在不同的作用域或块中，通过 let 重新声明变量是允许的：

**13.10** **提升hoisting**

通过 var 声明的变量会提升到顶端  您可以在声明变量之前就使用它。  通过 let 定义的变量不会被提升到顶端。  在声明 let 变量之前就使用它会导致 ReferenceError。 变量从块的开头一直处于“暂时死区”，直到声明为止。

**14 JavaScript Const**

使用 const 比使用 var 更安全，因为函数表达式始终是常量值。

如果函数是单个语句，则只能省略 return 关键字和大括号。因此，保留它们可能是一个好习惯。  通过 const 定义的变量与 let 变量类似，但不能重新赋值：

**14.1** **块作用域**

在块作用域内使用 const 声明的变量与 let 变量相似。

**14.2** **在声明时赋值**

JavaScript const 变量必须在声明时赋值。  不是真正的常数；关键字 const 有一定的误导性。；它没有定义常量值。它定义了对值的常量引用。 因此，我们不能更改常量原始值，但我们可以更改常量对象的属性。

**14.3原始值**

如果我们将一个原始值赋给常量，我们就不能改变原始值：

**14.4** **常量对象可以更改**

您可以更改常量对象的属性。  但是您无法重新为常量对象赋值：

**14.5常量数组可以更改**

您可以更改常量数组的元素，但是您无法重新为常量数组赋值。

Internet Explorer 10 或更早版本不支持 const 关键词。

**14.6** **重新声明**

在程序中的任何位置都允许重新声明 JavaScript var 变量。  在同一作用域或块中，不允许将已有的 var 或 let 变量重新声明或重新赋值给 const。 在同一作用域或块中，为已有的 const 变量重新声明声明或赋值是不允许的：

**14.7** **提升hoisting**

通过 var 定义的变量会被提升到顶端。 通过 const 定义的变量不会被提升到顶端const 变量不能在声明之前使用。

